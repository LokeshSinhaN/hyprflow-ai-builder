import os
import sys
from datetime import datetime
from typing import List

from fastapi import FastAPI, BackgroundTasks, HTTPException
from pydantic import BaseModel
from supabase import create_client, Client
from selenium import webdriver
from selenium.webdriver.chrome.options import Options
from selenium.common.exceptions import WebDriverException

SUPABASE_URL = os.environ["SUPABASE_URL"]
SUPABASE_KEY = os.environ["SUPABASE_SERVICE_KEY"]
BUCKET_NAME = os.getenv("SUPABASE_SCREENSHOT_BUCKET", "automation-screenshots")

supabase: Client = create_client(SUPABASE_URL, SUPABASE_KEY)


class JobRequest(BaseModel):
    script: str


app = FastAPI()


def update_job(job_id: str, **fields):
    supabase.table("automation_jobs").update(fields).eq("id", job_id).execute()


def upload_screenshot(job_id: str, path: str, update_latest: bool = True) -> str:
    storage_path = f"{job_id}/{os.path.basename(path)}"
    with open(path, "rb") as f:
        supabase.storage.from_(BUCKET_NAME).upload(storage_path, f, {"upsert": "true"})
    public_url = supabase.storage.from_(BUCKET_NAME).get_public_url(storage_path)
    if update_latest:
        update_job(job_id, latest_screenshot_url=public_url)
    return public_url


@app.get("/health")
async def health():
    return {"status": "ok"}


@app.post("/jobs/start")
async def start_job(payload: JobRequest, background: BackgroundTasks):
    """Insert a new automation job and execute it in the background."""
    # Create job row in Supabase
    res = (
        supabase.table("automation_jobs")
        .insert({"script": payload.script, "status": "queued"})
        .execute()
    )

    if not res.data or len(res.data) == 0 or "id" not in res.data[0]:
        raise HTTPException(status_code=500, detail="Failed to create automation job")

    job_id: str = res.data[0]["id"]

    # Start Selenium job in the background
    background.add_task(run_job, job_id)

    return {"jobId": job_id}


def run_job(job_id: str) -> None:
    # Fetch script from Supabase (so the DB is the source of truth)
    res = (
        supabase.table("automation_jobs")
        .select("script")
        .eq("id", job_id)
        .execute()
    )

    if not res.data or len(res.data) == 0:
        raise RuntimeError(f"automation_jobs row not found for id {job_id}")

    script = res.data[0]["script"]

    # Normalize known helper name variants generated by the LLM so they
    # match the helpers actually provided by the runtime. This avoids
    # trivial NameError crashes when the model invents small variations
    # of the supported helpers.
    helper_renames = {
        "capture_screenshot_if_available(": "capture_screenshot(",
        "_capture_screenshot(": "capture_screenshot(",
        "log_step(": "log(",
        "_log(": "log(",
    }
    for _old, _new in helper_renames.items():
        script = script.replace(_old, _new)

    # Mark job as running
    update_job(job_id, status="running")

    options = Options()
    options.add_argument("--headless=new")
    options.add_argument("--no-sandbox")
    options.add_argument("--disable-dev-shm-usage")

    driver = None
    log_lines: List[str] = []

    def log(msg: str) -> None:
        print(msg, flush=True)
        log_lines.append(msg)
        # Persist logs so the frontend can read them
        update_job(job_id, logs="\n".join(log_lines))

    try:
        # Create Selenium driver (Selenium Manager resolves compatible driver)
        driver = webdriver.Chrome(options=options)

        # Ensure any webdriver.Chrome(...) inside the generated script reuses this driver
        def _reuse_existing_driver(*_args, **_kwargs):
            return driver

        webdriver.Chrome = _reuse_existing_driver  # type: ignore[assignment]

        def capture_screenshot(label: str | None = None, update_latest: bool = True) -> str:
            safe_label = label.replace(" ", "-") if label else "step"
            filename = f"{job_id}-{safe_label}-{datetime.utcnow().isoformat()}.png"
            try:
                driver.save_screenshot(filename)
            except Exception as e:  # noqa: BLE001
                log(f"Failed to capture screenshot '{safe_label}': {e}")
                return ""
            try:
                return upload_screenshot(job_id, filename, update_latest=update_latest)
            except Exception as e:  # noqa: BLE001
                log(f"Failed to upload screenshot '{safe_label}': {e}")
                return ""

        # Convenience alias for scripts that call capture_screenshot_if_available(...)
        def capture_screenshot_if_available(label: str | None = None) -> str:
            return capture_screenshot(label, update_latest=True)

        # Wrap driver.quit so script-level quit still produces a debug screenshot
        original_quit = driver.quit

        def _wrapped_quit(*_args, **_kwargs):
            try:
                capture_screenshot("before-quit", update_latest=False)
            except Exception as e:  # noqa: BLE001
                print(f"Error capturing screenshot before quit: {e}", flush=True)
            try:
                return original_quit(*_args, **_kwargs)
            except Exception as e:  # noqa: BLE001
                print(f"Error while quitting driver: {e}", flush=True)
                return None

        driver.quit = _wrapped_quit  # type: ignore[assignment]

        # Execute the generated script as if run as __main__
        exec_globals = {
            "driver": driver,
            "log": log,
            "_log": log,
            "log_step": log,  # backwards-compatible alias for scripts using log_step
            "capture_screenshot": capture_screenshot,
            "capture_screenshot_if_available": capture_screenshot_if_available,
            "_capture_screenshot": capture_screenshot,
            "webdriver": webdriver,
            "WebDriverException": WebDriverException,
            "sys": sys,
            "__name__": "__main__",
        }
        exec(script, exec_globals, {})

        # Final best-effort screenshot for debugging without overwriting the last
        # meaningful screenshot.
        capture_screenshot("final", update_latest=False)

        update_job(job_id, status="completed", error_message=None)
    except Exception as e:  # noqa: BLE001
        log(f"Job {job_id} failed: {e}")
        update_job(job_id, status="failed", error_message=str(e))
        raise
    finally:
        if driver:
            try:
                driver.quit()
            except Exception:  # noqa: BLE001
                pass
